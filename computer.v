
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`timescale 1ns / 10ps
module computer(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	gpio0,
	gpio0_IN,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	gpio1,
	gpio1_IN 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// SW //////////
input 		     [3:0]		SW;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout 		    [33:0]		gpio0;
input 		     [1:0]		gpio0_IN;

//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
inout 		    [33:0]		gpio1;
input 		     [1:0]		gpio1_IN;


//=======================================================
//  REG/WIRE declarations
//=======================================================




//=======================================================
//  Structural coding
//=======================================================

localparam N = 5'd16;

// address bus, data bus
wire [N-1:0] addr, addr2;
wire [N-1:0] data, data2;
wire [N-1:0] data_to_write;

// memory read signal
reg rd, rd2;
// memory write signal
reg wr, wr2;
// IRQ signals
wire [7:0] irq;

// ###################
// Video VGA text instance 
// ###################

reg [1:0]vga_mode;
wire v0, v1;
assign v0 = (vga_mode == 2'b00);
assign v1 = (vga_mode == 2'b01);

vga_module vga0 (
	v0,
	
	//////////// CLOCK //////////
	CLOCK_50,

	//////////// RESET KEY //////////
	reset,

	//////////// GPIO //////////
	r, 
	g, 
	b, 
	hs, 
	vs,
	
	data2,
	addr2,
	rd2, 
	wr2
);

vga_320x240 vga1 (
	v1,
	
	//////////// CLOCK //////////
	CLOCK_50,

	//////////// RESET KEY //////////
	reset,

	//////////// GPIO //////////
	r, 
	g, 
	b, 
	hs, 
	vs,
	
	data2,
	addr2,
	rd2, 
	wr2
);


wire r, g, b, hs, vs;
wire vgaoe = 1'b1;

assign gpio0[3] = vgaoe ? r  : 1'bZ ;
assign gpio0[1] = vgaoe ? g  : 1'bZ ;
assign gpio0[0] = vgaoe ? b  : 1'bZ ;
assign gpio0[5] = vgaoe ? hs : 1'bZ ;
assign gpio0[7] = vgaoe ? vs : 1'bZ ;

// ####################################################################################################################
// RAM instance (dual port RAM; one port is connected to the CPU, while the other is connected to the video subsystem)
// ####################################################################################################################
RAM ram (
	CLOCK_50,
	data,
	addr,
	rd, wr,
	data_to_write,
	
	data2,
	addr2,
	rd2
);

// ####################################
// CPU instance
// ####################################
cpu cpu (
	CLOCK_50,
	reset, // reset key
	
	data,
	data_to_write,
	addr,
	rd,
	wr,
	irq,
	LED,
	rx_data_r,  // UART RX data
	tx_send,    // UART TX send signal
	tx_busy,    // UART TX busy signal
	tx_data,    // UART TX data
	vga_mode,	// VGA mode: 0-text; 1-320x240
	ps2_data_r	// keyboard data
);


// ####################################
// PS/2 keyboard instance
// ####################################
wire [7:0] ps2_data;
wire ps2_received;
reg [7:0] ps2_data_r;

ps2_read ps2(
  CLOCK_50,
  reset,
  gpio0[31], 		// Input pin - PS/2 data line
  gpio0[33], 		// Input pin - PS/2 clock line
  ps2_data,  		// here we will receive a character
  ps2_received    // if something came from serial, this goes high
);

// ####################################
// UART receiver instance
// ####################################
wire [7:0] rx_data;
wire rx_received;
reg [7:0] rx_data_r;

rx_serial rsr(
  CLOCK_50,
  reset,
  gpio0[27], 		// Input pin - receive line
  rx_data,  		// here we will receive a character
  rx_received    	// if something came from serial, this goes high
);

// ####################################
// UART transmitter instance
// ####################################
wire txoe = 1'b1;
wire [7:0] tx_data;
wire tx_send;
wire tx_busy;

tx_serial tsr(
  CLOCK_50,
  reset,
  tx_data, 		// Character to output
  tx_send,		// High = request a send
  gpio0[25],	// Output pin
  tx_busy		// High while character is being output
);

// ########################################
// IRQs & AUTO RESET after 50 clock cycles
// ########################################
reg [6:0] reset_counter;
wire timer_reset;
wire reset;

// reset is triggered when either KEY[0] is pressed, or auto reset timer has started (it holds reset for 5 cycles)
assign reset = !KEY[0] || timer_reset;

always @ (posedge CLOCK_50) begin
	// ############################### IRQ2 - keyboard #############################
	if (ps2_received) begin
		ps2_data_r <= ps2_data;
		// if we have received a byte from the keyboard, we will trigger the IRQ#2
		irq[2] <= 1'b1;
	end
	else 
	begin
		irq[2] <= 1'b0;
	end
	// ############################### IRQ1 - UART #############################
	if (rx_received) begin
		rx_data_r <= rx_data;
		// if we have received a byte from the UART, we will trigger the IRQ#1
		irq[1] <= 1'b1;
	end
	else 
	begin
		irq[1] <= 1'b0;
	end
	// ############################### IRQ0 - KEY 2 #############################
	if (!KEY[1]) begin
		// if the KEY[1] have beeen pressed, we will trigger the IRQ#0
		irq[0] <= 1'b1;
	end
	else begin
		irq[0] <= 1'b0;
	end
	// ############################### RESET & AUTOMATIC RESET #############################
	if (!KEY[0]) begin
		reset_counter <= 0;
		timer_reset <= 1'b1;
		irq <= 7'b0;
	end
	if (reset_counter < 50) begin
		reset_counter <= reset_counter + 1'b1;
		timer_reset <= 1'b1;
	end
	else begin
		timer_reset <= 1'b0;
	end
end

initial begin
	reset_counter <= 7'b0;
	timer_reset <= 1'b1;
	vga_mode <= 2'b00; // text mode
end

endmodule
